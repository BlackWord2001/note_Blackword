# <center> 高级绑定 </center>

高级绑定课程对blender基础有一定要求，建议能熟练使用blender后再看高级绑定课程，否测很多操作可能会看不懂。

## 01 Deformation skeleton

__骨骼名称中英文对照表__

__English__ | __中文__
:--- | :---
ROOT| 根
HEAD | 头部
NECK | 脖子
CHEST | 胸部 
SPINE | 脊柱 
HIP | 臀部 
LEG | 腿
SHIN | 小腿
FOOT | 脚
TOE | 脚趾
SHOULDER | 肩膀
ARM | 臂 
FORARM | 前臂 
HAND | 手
FINGER | 手指
THUMB | 拇指

给角色增加最基本的骨骼，命名以“DEF”开头。以及手臂和腿的部分需要对称镜像的骨骼在名称最后加上`.L` 的后缀名，这样在（编辑模式）下全选骨骼，右键选择（对称）就能识别并创建出 `.R` 后缀的镜像骨骼。



↓ 绑定参考图

![图像](./Images/高级绑定P01-2.png)

↓ 脚骨骼侧面图

![图像](./Images/高级绑定P01-3.png)

↓ 手指

![图像 | 300](./Images/高级绑定P01-4.png)

↓ ROOT骨骼

> 绑定时一定要注意骨骼坐标轴的朝向，Z轴永远朝上或者朝前。
![图像 | 300](./Images/高级绑定P01-5.png)


↓ DEF骨骼最后完成的样子


正视图 | 侧视图
:---: | :---:
![图像](./Images/高级绑定P01-1.png) | ![图像](./Images/高级绑定P01-6.png)

## 02 骨骼管理器

接下来就要使用（Bone Manager）插件对骨骼进行分类管理，

插件下载地址请查看：[Blender-插件.md](../Blender-插件.md)

这部分我们要做的很简单，只需要专门新建一个ROOT层，并选中ROOT骨骼点击右侧的圆圈“○”给放进去就ok了。

![图像](./Images/高级绑定P01-7.png)

## 03 Assigning armature

因为绑定的模型可能会导入游戏引擎所以TGT骨骼是专门用来专门控制DEF骨骼的，相当于是一层控制器。

1. 第一步需要我们在（编辑模式）下把除了ROOT骨骼将DEF开头的骨骼全都选中按 <Kbd>Shift</Kbd> + <Kbd>D</Kbd> 复制一份。

2. 把复制出来的骨骼全部放到一个新的层级中，并把层级命名为TGT。

    ![图像](./Images/高级绑定P01-8.png)

3. 隐藏其他层就单独显示TGT骨骼层，然后将TGT层的骨骼全选，按下<Kbd>Ctrl</Kbd> + <Kbd>F2</Kbd> 进行批量重命名把DEF的前缀替换成TGT。

    ![图像](./Images/高级绑定P01-9.png)

4. 清除blender给我们创建的后缀，复制后的物体因为和原物体重名blender会给我们在名称末尾加上.001 .002 ...等编号，现在我们需要删除他。保险起见我们分两步操作

    > 先删除末尾的数字
    ![图像](./Images/高级绑定P01-10.png)

    > 再删除标点
    ![图像](./Images/高级绑定P01-11.png)

5. 然后就是把DEF捆绑在TGT上，这里我们使用约束修改器，先选择DEF再选中相应的TGT骨骼，按下<Kbd>Ctrl</Kbd> + <Kbd>Shift</Kbd> + <Kbd>C</Kbd> 选择（Copy Transforms）复制变换就好了，接下来就是体力活把所有DEF骨骼都绑到对应的TGT骨骼上。

    ![图像](./Images/高级绑定P01-12.png)

    ↓ 添加完（Copy Transforms）约束后就可以在DEF的约束面板看见它

    ![图像](./Images/高级绑定P01-13.png)

6. 在刷权重之前我们需要把ROOT和TGT开头的所有骨骼的（形变）全部关闭，要不然blender会给我们创建这些骨骼的定点组，我们只需要DEF骨骼驱动人物模型就可以了，因此我们并不需要这些顶点组。

    ![图像](./Images/高级绑定P01-14.png)

7. 先选中物体再加选骨骼按下 <Kbd>Ctrl</Kbd> + <Kbd>P</Kbd> 选择（附带空顶点组），就完成物体和骨骼的关联了
   
    ![图像](./Images/高级绑定P01-15.png)

    ↓ 顶点组的名称会和骨骼名称一模一样，简单的模型如机器人等关节分离的模型可以直接在这个面板中使用（指定）按钮创建权重。

    ![图像](./Images/高级绑定P01-16.png)

    （编辑模式）下打开顶点组权重选项，再选择对应的顶点组就能看到直观的权重影响范围。

    ![图像](./Images/高级绑定P01-17.png)

8. 刷权重部分省略....
   
## 04 躯干控制器

把DEF层先给隐藏，只留下TGT和ROOT方便观察

![图像](./Images/高级绑定-18.png)

从（TGT-HIPS）骨骼沿着Y轴挤出一条名为（CTRL-TORSO） 

![图像](./Images/高级绑定-19.png)

新建一个层把他命名为（TORSO）将（CTRL-TORSO）放到这个新建的层中

![图像](./Images/高级绑定-20.png)

复制一根（TGT-HIPS）骨骼并命名为（CTRL-HIPS）用来作为臀部控制，然后选中这根骨骼并使用快捷键 <kbd>Alt</kbd> - <kbd>F</kbd> 来反转他，并把将（CTRL-HIPS）使用设置为 （CTRL-TORSO）的子级。

![图像](./Images/高级绑定-21.png)

再拉出一根名为（CTRL-CHEST）的骨骼用来控制我们胸部或躯干整个上半部分，也设置为CTRL-TORSO的子集。

![图像](./Images/高级绑定-22.png)

把其他层的骨骼都给隐藏只留下TORSO层最后效果如下

![图像](./Images/高级绑定-23.png)

↓ 骨骼父子关系参考如下

![图像](./Images/高级绑定-24.png)

基础的控制骨骼已经创建完毕，接下来就开始实现控制躯干和臀部的功能

1. 先把 _TGT_HIPS_ 的父级设置为 _CTRL_HIPS_

    ![图像](./Images/高级绑定-25.png)

    > 但是现在出现了一个问题，当我们去旋转 _CTRL_HIPS_ 骨骼整个角色都会旋转，这根骨骼的作用是单纯用来控制臀部的接下来将修复这个问题。

    以上问题根本的原因还是因为 _TGT_SPINE_ 的父级是 _TGT_HIPS_ 当这根骨骼旋转的时候同时也会带动 _TGT_SPINE_ 所以会出现臀部以上也跟着一起旋转的效果。解决办法也很简单只需要把 _TGT_SPINE_ 的父级设置为 _CTRL_TORSO_ 就可以了。

    ![图像](./Images/高级绑定-26.png)

2. 先选中 _CTRL-CHEST_ 再加选 _TGT-SPINE_ ，<kbd>Ctrl</kbd> - <kbd>Shift</kbd> - <kbd>C</kbd> → [ __Copy Rotation__ ](https://docs.blender.org/manual/zh-hans/3.6/animation/constraints/transform/copy_rotation.html) 

    - 目标和拥有者都设置为（局部空间）
    - Mix设置为（相加），或者用（偏移）也可以

    以上步骤设置完后就可以使用 _CTRL_SPINE_ 控制 _TGT_SPINE_ 了，_TGT_SPINE_ 也可以单独进行旋转。

    ![图像](./Images/高级绑定-27.png)

    如果没有把Mix设置为（相加）_TGT_SPINE_ 就无法单独旋转。

    ![图像](./Images/高级绑定-28.png)

3. 先选中 _CTRL-CHEST_ 再加选 _TGT-CHEST_ ，<kbd>Ctrl</kbd> - <kbd>Shift</kbd> - <kbd>C</kbd> → [ __Copy Rotation__ ](https://docs.blender.org/manual/zh-hans/3.6/animation/constraints/transform/copy_rotation.html)

    ![图像](./Images/高级绑定-29.png)

    最终效果就是只需要旋转 _CTRL_SPINE_ 就能同时控制 _TGT-SPINE_ 和 _TGT-CHEST_

    ![图像](./Images/高级绑定-30.png)

4. 最后一步我们要来修改骨骼的名称，因为 _TGT_CHEST_ 和 TGT_SPINE 可以直接允许控制腰部胸部的旋转所以我们也给他改名并归类为 CTRL。
   
    - _TGT_CHEST_ → _CTRL_TWEAKS_CHEST_
    - _TGT_SPINE_ → _CTRL_TWEAKS_SPINE_

    以上两根骨骼名称修改完后，再将其分类进 _TORSO_ 骨骼层

    ![图像](./Images/高级绑定-31.png)

## 05 头部和颈部

开始前先打开骨骼的线框显示模式，有利于制作时候的观察！

![图像](./Images/高级绑定-33.png)

在BoneLayers插件面板中先创建一个名为“MCH”的骨骼层，接下来我们创建的MCH开头的骨骼就给他全放在这个层中。

从脖子下方拉出一根骨骼命名未 “MCH-NECK-ROT”

![图像](./Images/高级绑定-32.png)

再复制一根“MCH-NECK-ROT”骨骼缩小后改名为“MCH-NECK-INT-ROT”

![图像](./Images/高级绑定-34.png)

将 “MCH-NECK-INT-ROT” 骨骼设置为 "CTRL-TORSO" 的子级

![图像](./Images/高级绑定-35.png)

再把脖子的控制骨骼 "TGT-NECK" 设置为 "MCH-NECK-INT-ROT" 的子级

![图像 ](./Images/高级绑定-36.png)

先选中 "MCH-NECK-ROT" 再加选  "MCH-NECK-INT-ROT" 然后按下快捷键 <kbd>CTRL</kbd> - <kbd>SHIFT</kbd> - <kbd>C</kbd> 添加骨骼约束

![图像 ](./Images/高级绑定-37.png)

再给其中的 "Copy Rotation" 约束改名为 "Copy Rotation-NECK-FOLLOW" 方便辨认

![图像 ](./Images/高级绑定-38.png)

接下来就是确认 “MCH-NECK-ROT” 的父级是 “CTRL_TWEAKS_CHEST”，如果不是就将他设置为父级。

![图像 ](./Images/高级绑定-39.png)

现在旋转我们的 “CTRL-CHEST” 还没什么效果，我们只需要把脖子骨骼的的 "Copy Rotation-NECK-FOLLOW" 约束下的影响设置为 "0" 就可以了。

![图像 ](./Images/高级绑定-40.png)

最后我们就能做到无论身体怎么旋转，头部始终都是朝着上方屹立不倒。

## 06初见驱动器

驱动器通过函数来控制属性值。

事实上，驱动器由以下部分组成:

- **驱动器配置** ，指定0个，1个或多个使用其他属性或物体变换通道的输入值，并使用预定义的数学函数或自定义的Python表达式将其结合在一起。
    
- **动画** [函数曲线](https://docs.blender.org/manual/zh-hans/3.5/editors/graph_editor/fcurves/introduction.html)，将驱动配置的输出映射到最终值，以应用到被驱动属性。
    

例如，物体1的旋转可以被物体2的位置控制。可以说，物体2的位置驱动物体1旋转。

驱动器不仅可以调用大多数属性值，直接映射到其他属性，而且属性也可以作为数学表达式或者Python脚本的一部分，通过函数进一步调整。

驱动器是构建装备的极其强大的工具，通常用于驱动骨骼变换以及形状键，操作约束和影响修改器，通常使用自定义属性作为输入。

### 驱动器简单使用

首先如下图在场景中创建一个球体和立方体

![驱动器](./images/驱动器-01.png)

给立方体的Z轴缩放右键添加驱动器
![驱动器](./images/驱动器-02.png)

在驱动器面板编辑驱动器会更方便一些，如下图给驱动器添加物体。

![驱动器](./images/驱动器-03.png)

当按照上面的步骤设置完后我们可以向着X轴左右移动我们的球体就会发现正方形Z轴就会缩放，从正方形拉伸成为了长方体。

![驱动器](./images/驱动器-04.png)

没看懂发生了什么的话我来仔细解释一下驱动器的设置，如下图表达式中 var + 1.0 从最终效果上来看其实就是设置一个初始值，var是我们驱动器的变量名称。

如果删除 var后面的内容或者写成 var + 0，那么这两种方法效果是一样的都会使立方体z轴缩放为0被压成一个平面。

物体很简单就是用来控制当前驱动器的目标物体，类型为X位置的意思是让球体沿着X轴移动就会驱动当前驱动器，间隔（空间）就是设置当前目标物体是沿着世界空间的X轴还是自身的局部空间的X轴。

![驱动器](./images/驱动器-05.png)

### 驱动器曲线

驱动器曲线的操作和作用和动画曲线类似，当球体往X轴移动1的时候立方体的Z轴缩放也会相应的被+1；

![驱动器](./images/驱动器-06.png)

![驱动器](./images/驱动器-07.png)

但是当我们手动编辑曲线后这个1:1的变化就能被打破，默认的曲线是一条线性曲线，球体向X轴移动多少立方体的Z轴就相应缩放多少数值。

接下来先学会怎么使用曲线编辑器，曲线的初始坐标位置是0,0 。

![驱动器](./images/驱动器-08.png)

<kbd>Ctrl</kbd> + <kbd>MMB</kbd> 上下左右移动调整曲线编辑器界面的缩放

![驱动器](./images/驱动器-09.png)

<kbd>Ctrl</kbd> + <kbd>RMB</kbd> 可以移动光标的位置，蓝色的十字线就是光标

![驱动器](./images/驱动器-10.png)

现在我们就要开始编辑曲线了，右键后在上下文菜单选择（插入关键帧），但是注意这个关键帧并不是在我们的当前鼠标光标的位置创建的，而是在这条蓝色的十字线上创建的，也就是曲线编辑器的专属光标。

![驱动器](./images/驱动器-11.png)

创建完后，可以把曲线设置为自由，这样会变成贝塞尔曲线会比较好控制。

> 如果你的控制柄并不是贝塞尔曲线的效果可以设置插值模式为（贝塞尔），快捷键 T

![驱动器](./images/驱动器-12.png)

使用快捷键 <kbd>Shift</kbd> + <kbd>D</kbd> 就能直接创建新的关键帧。

![驱动器](./images/驱动器-13.png)

当设置成这样的时候我们再去移动球体的时候，会发现移动相同的距离但是立方体的Z轴会更长，但是越往后移动Z轴反而会反向拉伸。

### 自定义属性

先删除之前所有的内容，再重新创建一个球体和立方体，还是在立方体的z轴上添加驱动器
在球体上物体属性上添加一个（自定义属性）如下图：

![驱动器](./images/驱动器-15.png)
↓ 自定义属性设置

![驱动器](./images/驱动器-14.png) 

如图右键自定义属性选择（复制数据路径）

![驱动器](./images/驱动器-16.png) 

最后再设置一下立方体的驱动器如下图：

![驱动器](./images/驱动器-17.png) 

然后当我们滑动前面创建的自定义属性的时候立方体的长度也会跟着变化，注意现在CUBE-SIZE的参数是0.579

![驱动器](./images/驱动器-18.png) 

立方体默认Z轴缩放是1，所以加上0.579就是1.579

![驱动器](./images/驱动器-19.png) 

## 07 驱动器实战


接下来需要使用驱动器给，头部永远朝上的模式做一个开关方便后续控制。

需要在头顶上创建一根名为“PROPERTIES”的骨骼中文可以翻译为“偏好设置”的骨骼，之后所有的“自定义属性”都会创建在这根骨骼中。

![驱动器](./images/驱动器实战-01.png) 

但是再开始之前需要给头部创建一根像脖子上一样的能让它永远朝上的骨骼，具体可以再去看看上面的《05 头部和颈部》章节，这节内容主要用来对驱动器和自定义参数的实战就不赘述之前已经学过的内容了。

↓成品图

![驱动器](./images/驱动器实战-02.png) 

> 因为我在跟教程的时候已经把blender升级到了4.0版本，这个版本更新了骨骼层的管理方式，所以我们将不再需要使用 Bone Manager 插件。

还有一点需要说明的是成品图中骨骼部分已经重新做了分类，如下：

让脖子永远朝上的骨骼全部都放在MCH骨骼集合中；顺便在创建头部朝上骨骼的时候可以参考截图中的命名方式。

↓ 骨骼集合：MCH

![驱动器](./images/驱动器实战-03.png)

↓ 骨骼集合：TORSO-TWEAK

![驱动器](./images/驱动器实战-04.png)

↓ 骨骼集合：TORSO

![驱动器](./images/驱动器实战-05.png)

如下图需要在 “PROPERTIES” 骨骼下创建两个“自定义属性”。

![驱动器](./images/高级绑定P07-1.png)

+ HEAD-FOLLOW：控制头部始终朝上
+ NECK-FOLLOW：控制脖子始终朝上

↓ 驱动器设置

![驱动器](./images/高级绑定P07-2.png)

复制 HEAD-FOLLOW 的（数据路径），然后进入 MCH-INT-HEAD-FOLLOW 的骨骼约束设置

![驱动器](./images/高级绑定P07-3.png)

再打开驱动器编辑器，如下图设置驱动器，再把前面复制的 HEAD-FOLLOW 的数据路径复制到驱动器中。

![驱动器](./images/高级绑定P07-4.png)

NECK-FOLLOW 也和上面一样操作就可以了，这里就不多赘述了。最后把自定义属性中的参数设置为如下图所示，再去转动我们的身体就会发现头部永远朝上了。

![驱动器](./images/高级绑定P07-5.png)

↓ 最终效果

![驱动器](./images/高级绑定P07-6.png)

## 08 IK反向动力学

给腿部增加反向动力学

首先需要先从脚后跟这个位置拉出一根名为 MCH-IK-FOOT.L 的骨骼，这根骨骼就是现在用来控制IK骨的。MCH-IK-FOOT.L 需要断开原来的父级关系，并如下图把父级设置为ROOT骨骼。

![驱动器](./images/高级绑定P08-2.png)

↓ 极向骨骼等设置

![驱动器](./images/高级绑定P08-3.webp)

一定要锁定 TGT-SHIN.L 的 YZ轴，否则腿会出现不自然的弯曲。            

![驱动器](./images/高级绑定P08-4.webp)

↓ 最终效果图

![驱动器](./images/高级绑定P08-1.png)

## 09 脚步控制器

给脚增加控制骨骼，让制作动画和摆pose更易操控。

### IK骨修改

首先第一步按照顺序先选中 `MCH-IK-FOOT.L` 再加选 `TGT-FOOT.L`

![图片](./Images/高级绑定P09-1.webp)

按下快捷键 <kbd>Ctrl</kbd> - <kbd>Alt</kbd> - <kbd>A</kbd> 来对齐骨骼；再调整一下 `MCH-IK-FOOT.L` 的大小得到如下图的结果。

> 缩放的时候需要把变换轴心点设置成（各自的原点），否则会导致骨骼会往两端缩放。

![图片](./Images/高级绑定P09-2.webp)

再依次选中 `MCH-IK-FOOT.L` `TGT-FOOT.L` 然后 <kbd>Ctrl</kbd> - <kbd>Shift</kbd> - <kbd>C</kbd> 给 `TGT-FOOT.L` 添加约束：（复制变换）；

现在它不仅控制了IK，它还允许我们移动和旋转脚部。

![图片](./Images/高级绑定P09-3.webp)

### DEF骨骼修改

当我们把模型导出到其他软件时会出现一些问题，所以我们的解决方案是先把DEF骨骼的父级全部解除。

![图片](./Images/高级绑定P09-4.webp)

最后再将`DEF`所有的骨骼的父级统一设置为`ROOT`。

![图片](./Images/高级绑定P09-5.webp)

### 控制骨骼

接下来我们需要创建一根骨骼叫做`MCH-FOOR-ROLL.L`并清空他的父级；然后再从它的后面再拉出一根`MCH-FOOR-ROLL02.L`的骨骼。

> 注意：注意图中新建骨骼的Z轴朝向，Z轴永远朝前或朝上，如果朝向不对可以在（骨骼编辑模式）中从（N面板）>（条目）中设置（扭转）值。

![图片](./Images/高级绑定P09-6.webp)

然后按照如下图设置父级关系，`MCH-IK-FOOT.L`的父级为`MCH-FOOR-ROLL.L`；`MCH-FOOR-ROLL.L`的父级为`MCH-FOOR-ROLL02.L`。

![图片](./Images/高级绑定P09-7.webp)

绑定的效果如下

旋转和移动`MCH-FOOR-ROLL.L`

![图片](./Images/高级绑定P09-8.webp)

旋转`MCH-FOOR-ROLL02.L`

![图片](./Images/高级绑定P09-9.webp)

### 创建控制器

先创建一根 `CTRL-FOOR-ROLL02.L` 控制骨骼；依次选中`CTRL-FOOR-ROLL02.L`，`MCH-FOOR-ROLL.L`按下快捷键 <kbd>Ctrl</kbd> - <kbd>Shift</kbd> - <kbd>C</kbd> 添加约束，约束中设置把除了X轴以外的影响全部关掉；再把目标和拥有者的空间都改为局部空间。

![图片](./Images/高级绑定P09-10.webp)

再添加一个约束（限定旋转），如图设置把最大值设置为180°；把拥有者的空间设置为（局部空间）

![图片](./Images/高级绑定P09-11.webp)

给`MCH-FOOR-ROLL02.L`也添加相同的约束；有个快捷方法就是可以先选中`MCH-FOOR-ROLL02.L`再加选 `MCH-FOOR-ROLL.L`从3D视图的菜单栏中选择 （姿态）>（约束）>（将约束复制到当前所选骨骼）就可以把`MCH-FOOR-ROLL.L`的约束直接传递到`MCH-FOOR-ROLL02.L`上。

然后只需要按照下图把最小值修改为-180°，最大值设置为0°就可以了。

![图片](./Images/高级绑定P09-12.webp)

## 10 修复腿部

修复骨骼拉伸出现整条腿被拉大的问题，其次是对骨骼重新分类以及初次修改旋转模式。
## 11 旋转模式

了解不同选择模式之间的区别，以及学会什么情况下该用什么旋转 模式。
