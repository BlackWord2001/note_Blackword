# <center> 高级绑定 </center>

高级绑定课程对blender基础有一定要求，建议能熟练使用blender后再看高级绑定课程，否测很多操作可能会看不懂。

## 01 Deformation skeleton

__骨骼名称中英文对照表__

__English__ | __中文__
:--- | :---
ROOT| 根
HEAD | 头部
NECK | 脖子
CHEST | 胸部 
SPINE | 脊柱 
HIP | 臀部 
LEG | 腿
SHIN | 小腿
FOOT | 脚
TOE | 脚趾
SHOULDER | 肩膀
ARM | 臂 
FORARM | 前臂 
HAND | 手
FINGER | 手指
THUMB | 拇指

给角色增加最基本的骨骼，命名以“DEF”开头。以及手臂和腿的部分需要对称镜像的骨骼在名称最后加上`.L` 的后缀名，这样在（编辑模式）下全选骨骼，右键选择（对称）就能识别并创建出 `.R` 后缀的镜像骨骼。



↓ 绑定参考图

![图像](./Images/高级绑定P01-2.png)

↓ 脚骨骼侧面图

![图像](./Images/高级绑定P01-3.png)

↓ 手指

![图像 | 300](./Images/高级绑定P01-4.png)

↓ ROOT骨骼

> 绑定时一定要注意骨骼坐标轴的朝向，Z轴永远朝上或者朝前。
![图像 | 300](./Images/高级绑定P01-5.png)


↓ DEF骨骼最后完成的样子


正视图 | 侧视图
:---: | :---:
![图像](./Images/高级绑定P01-1.png) | ![图像](./Images/高级绑定P01-6.png)

## 02 骨骼管理器

接下来就要使用（Bone Manager）插件对骨骼进行分类管理，

插件下载地址请查看：[Blender-插件.md](../Blender-插件.md)

这部分我们要做的很简单，只需要专门新建一个ROOT层，并选中ROOT骨骼点击右侧的圆圈“○”给放进去就ok了。

![图像](./Images/高级绑定P01-7.png)

## 03 Assigning armature

因为绑定的模型可能会导入游戏引擎所以TGT骨骼是专门用来专门控制DEF骨骼的，相当于是一层控制器。

1. 第一步需要我们在（编辑模式）下把除了ROOT骨骼将DEF开头的骨骼全都选中按 <Kbd>Shift</Kbd> + <Kbd>D</Kbd> 复制一份。

2. 把复制出来的骨骼全部放到一个新的层级中，并把层级命名为TGT。

    ![图像](./Images/高级绑定P01-8.png)

3. 隐藏其他层就单独显示TGT骨骼层，然后将TGT层的骨骼全选，按下<Kbd>Ctrl</Kbd> + <Kbd>F2</Kbd> 进行批量重命名把DEF的前缀替换成TGT。

    ![图像](./Images/高级绑定P01-9.png)

4. 清除blender给我们创建的后缀，复制后的物体因为和原物体重名blender会给我们在名称末尾加上.001 .002 ...等编号，现在我们需要删除他。保险起见我们分两步操作

    > 先删除末尾的数字
    ![图像](./Images/高级绑定P01-10.png)

    > 再删除标点
    ![图像](./Images/高级绑定P01-11.png)

5. 然后就是把DEF捆绑在TGT上，这里我们使用约束修改器，先选择DEF再选中相应的TGT骨骼，按下<Kbd>Ctrl</Kbd> + <Kbd>Shift</Kbd> + <Kbd>C</Kbd> 选择（Copy Transforms）复制变换就好了，接下来就是体力活把所有DEF骨骼都绑到对应的TGT骨骼上。

    ![图像](./Images/高级绑定P01-12.png)

    ↓ 添加完（Copy Transforms）约束后就可以在DEF的约束面板看见它

    ![图像](./Images/高级绑定P01-13.png)

6. 在刷权重之前我们需要把ROOT和TGT开头的所有骨骼的（形变）全部关闭，要不然blender会给我们创建这些骨骼的定点组，我们只需要DEF骨骼驱动人物模型就可以了，因此我们并不需要这些顶点组。

    ![图像](./Images/高级绑定P01-14.png)

7. 先选中物体再加选骨骼按下 <Kbd>Ctrl</Kbd> + <Kbd>P</Kbd> 选择（附带空顶点组），就完成物体和骨骼的关联了
   
    ![图像](./Images/高级绑定P01-15.png)

    ↓ 顶点组的名称会和骨骼名称一模一样，简单的模型如机器人等关节分离的模型可以直接在这个面板中使用（指定）按钮创建权重。

    ![图像](./Images/高级绑定P01-16.png)

    （编辑模式）下打开顶点组权重选项，再选择对应的顶点组就能看到直观的权重影响范围。

    ![图像](./Images/高级绑定P01-17.png)

8. 刷权重部分省略....
   
## 04 躯干控制器

把DEF层先给隐藏，只留下TGT和ROOT方便观察

![图像](./Images/高级绑定-18.png)

从（TGT-HIPS）骨骼沿着Y轴挤出一条名为（CTRL-TORSO） 

![图像](./Images/高级绑定-19.png)

新建一个层把他命名为（TORSO）将（CTRL-TORSO）放到这个新建的层中

![图像](./Images/高级绑定-20.png)

复制一根（TGT-HIPS）骨骼并命名为（CTRL-HIPS）用来作为臀部控制，然后选中这根骨骼并使用快捷键 <kbd>Alt</kbd> - <kbd>F</kbd> 来反转他，并把将（CTRL-HIPS）使用设置为 （CTRL-TORSO）的子级。

![图像](./Images/高级绑定-21.png)

再拉出一根名为（CTRL-CHEST）的骨骼用来控制我们胸部或躯干整个上半部分，也设置为CTRL-TORSO的子集。

![图像](./Images/高级绑定-22.png)

把其他层的骨骼都给隐藏只留下TORSO层最后效果如下

![图像](./Images/高级绑定-23.png)

↓ 骨骼父子关系参考如下

![图像](./Images/高级绑定-24.png)

基础的控制骨骼已经创建完毕，接下来就开始实现控制躯干和臀部的功能

1. 先把 _TGT_HIPS_ 的父级设置为 _CTRL_HIPS_

    ![图像](./Images/高级绑定-25.png)

    > 但是现在出现了一个问题，当我们去旋转 _CTRL_HIPS_ 骨骼整个角色都会旋转，这根骨骼的作用是单纯用来控制臀部的接下来将修复这个问题。

    以上问题根本的原因还是因为 _TGT_SPINE_ 的父级是 _TGT_HIPS_ 当这根骨骼旋转的时候同时也会带动 _TGT_SPINE_ 所以会出现臀部以上也跟着一起旋转的效果。解决办法也很简单只需要把 _TGT_SPINE_ 的父级设置为 _CTRL_TORSO_ 就可以了。

    ![图像](./Images/高级绑定-26.png)

2. 先选中 _CTRL-CHEST_ 再加选 _TGT-SPINE_ ，<kbd>Ctrl</kbd> - <kbd>Shift</kbd> - <kbd>C</kbd> → [ __Copy Rotation__ ](https://docs.blender.org/manual/zh-hans/3.6/animation/constraints/transform/copy_rotation.html) 

    - 目标和拥有者都设置为（局部空间）
    - Mix设置为（相加），或者用（偏移）也可以

    以上步骤设置完后就可以使用 _CTRL_SPINE_ 控制 _TGT_SPINE_ 了，_TGT_SPINE_ 也可以单独进行旋转。

    ![图像](./Images/高级绑定-27.png)

    如果没有把Mix设置为（相加）_TGT_SPINE_ 就无法单独旋转。

    ![图像](./Images/高级绑定-28.png)

3. 先选中 _CTRL-CHEST_ 再加选 _TGT-CHEST_ ，<kbd>Ctrl</kbd> - <kbd>Shift</kbd> - <kbd>C</kbd> → [ __Copy Rotation__ ](https://docs.blender.org/manual/zh-hans/3.6/animation/constraints/transform/copy_rotation.html)

    ![图像](./Images/高级绑定-29.png)

    最终效果就是只需要旋转 _CTRL_SPINE_ 就能同时控制 _TGT-SPINE_ 和 _TGT-CHEST_

    ![图像](./Images/高级绑定-30.png)

4. 最后一步我们要来修改骨骼的名称，因为 _TGT_CHEST_ 和 TGT_SPINE 可以直接允许控制腰部胸部的旋转所以我们也给他改名并归类为 CTRL。
   
    - _TGT_CHEST_ → _CTRL_TWEAKS_CHEST_
    - _TGT_SPINE_ → _CTRL_TWEAKS_SPINE_

    以上两根骨骼名称修改完后，再将其分类进 _TORSO_ 骨骼层

    ![图像](./Images/高级绑定-31.png)

## 05 头部和颈部

开始前先打开骨骼的线框显示模式，有利于制作时候的观察！

![图像](./Images/高级绑定-33.png)

在BoneLayers插件面板中先创建一个名为“MCH”的骨骼层，接下来我们创建的MCH开头的骨骼就给他全放在这个层中。

从脖子下方拉出一根骨骼命名未 “MCH-NECK-ROT”

![图像](./Images/高级绑定-32.png)

再复制一根“MCH-NECK-ROT”骨骼缩小后改名为“MCH-NECK-INT-ROT”

![图像](./Images/高级绑定-34.png)

将 “MCH-NECK-INT-ROT” 骨骼设置为 "CTRL-TORSO" 的子级

![图像](./Images/高级绑定-35.png)

再把脖子的控制骨骼 "TGT-NECK" 设置为 "MCH-NECK-INT-ROT" 的子级

![图像 ](./Images/高级绑定-36.png)

先选中 "MCH-NECK-ROT" 再加选  "MCH-NECK-INT-ROT" 然后按下快捷键 <kbd>CTRL</kbd> - <kbd>SHIFT</kbd> - <kbd>C</kbd> 添加骨骼约束

![图像 ](./Images/高级绑定-37.png)

再给其中的 "Copy Rotation" 约束改名为 "Copy Rotation-NECK-FOLLOW" 方便辨认

![图像 ](./Images/高级绑定-38.png)

接下来就是确认 “MCH-NECK-ROT” 的父级是 “CTRL_TWEAKS_CHEST”，如果不是就将他设置为父级。

![图像 ](./Images/高级绑定-39.png)

现在旋转我们的 “CTRL-CHEST” 还没什么效果，我们只需要把脖子骨骼的的 "Copy Rotation-NECK-FOLLOW" 约束下的影响设置为 "0" 就可以了。

![图像 ](./Images/高级绑定-40.png)

最后我们就能做到无论身体怎么旋转，头部始终都是朝着上方屹立不倒。

## 06初见驱动器

驱动器通过函数来控制属性值。

事实上，驱动器由以下部分组成:

- **驱动器配置** ，指定0个，1个或多个使用其他属性或物体变换通道的输入值，并使用预定义的数学函数或自定义的Python表达式将其结合在一起。
    
- **动画** [函数曲线](https://docs.blender.org/manual/zh-hans/3.5/editors/graph_editor/fcurves/introduction.html)，将驱动配置的输出映射到最终值，以应用到被驱动属性。
    

例如，物体1的旋转可以被物体2的位置控制。可以说，物体2的位置驱动物体1旋转。

驱动器不仅可以调用大多数属性值，直接映射到其他属性，而且属性也可以作为数学表达式或者Python脚本的一部分，通过函数进一步调整。

驱动器是构建装备的极其强大的工具，通常用于驱动骨骼变换以及形状键，操作约束和影响修改器，通常使用自定义属性作为输入。

### 驱动器简单使用

首先如下图在场景中创建一个球体和立方体

![驱动器](./images/驱动器-01.png)

给立方体的Z轴缩放右键添加驱动器
![驱动器](./images/驱动器-02.png)

在驱动器面板编辑驱动器会更方便一些，如下图给驱动器添加物体。

![驱动器](./images/驱动器-03.png)

当按照上面的步骤设置完后我们可以向着X轴左右移动我们的球体就会发现正方形Z轴就会缩放，从正方形拉伸成为了长方体。

![驱动器](./images/驱动器-04.png)

没看懂发生了什么的话我来仔细解释一下驱动器的设置，如下图表达式中 var + 1.0 从最终效果上来看其实就是设置一个初始值，var是我们驱动器的变量名称。

如果删除 var后面的内容或者写成 var + 0，那么这两种方法效果是一样的都会使立方体z轴缩放为0被压成一个平面。

物体很简单就是用来控制当前驱动器的目标物体，类型为X位置的意思是让球体沿着X轴移动就会驱动当前驱动器，间隔（空间）就是设置当前目标物体是沿着世界空间的X轴还是自身的局部空间的X轴。

![驱动器](./images/驱动器-05.png)

### 驱动器曲线

驱动器曲线的操作和作用和动画曲线类似，当球体往X轴移动1的时候立方体的Z轴缩放也会相应的被+1；

![驱动器](./images/驱动器-06.png)

![驱动器](./images/驱动器-07.png)

但是当我们手动编辑曲线后这个1:1的变化就能被打破，默认的曲线是一条线性曲线，球体向X轴移动多少立方体的Z轴就相应缩放多少数值。

接下来先学会怎么使用曲线编辑器，曲线的初始坐标位置是0,0 。

![驱动器](./images/驱动器-08.png)

<kbd>Ctrl</kbd> + <kbd>MMB</kbd> 上下左右移动调整曲线编辑器界面的缩放

![驱动器](./images/驱动器-09.png)

<kbd>Ctrl</kbd> + <kbd>RMB</kbd> 可以移动光标的位置，蓝色的十字线就是光标

![驱动器](./images/驱动器-10.png)

现在我们就要开始编辑曲线了，右键后在上下文菜单选择（插入关键帧），但是注意这个关键帧并不是在我们的当前鼠标光标的位置创建的，而是在这条蓝色的十字线上创建的，也就是曲线编辑器的专属光标。

![驱动器](./images/驱动器-11.png)

创建完后，可以把曲线设置为自由，这样会变成贝塞尔曲线会比较好控制。

> 如果你的控制柄并不是贝塞尔曲线的效果可以设置插值模式为（贝塞尔），快捷键 T

![驱动器](./images/驱动器-12.png)

使用快捷键 <kbd>Shift</kbd> + <kbd>D</kbd> 就能直接创建新的关键帧。

![驱动器](./images/驱动器-13.png)

当设置成这样的时候我们再去移动球体的时候，会发现移动相同的距离但是立方体的Z轴会更长，但是越往后移动Z轴反而会反向拉伸。

### 自定义属性

先删除之前所有的内容，再重新创建一个球体和立方体，还是在立方体的z轴上添加驱动器
在球体上物体属性上添加一个（自定义属性）如下图：

![驱动器](./images/驱动器-15.png)
↓ 自定义属性设置

![驱动器](./images/驱动器-14.png) 

如图右键自定义属性选择（复制数据路径）

![驱动器](./images/驱动器-16.png) 

最后再设置一下立方体的驱动器如下图：

![驱动器](./images/驱动器-17.png) 

然后当我们滑动前面创建的自定义属性的时候立方体的长度也会跟着变化，注意现在CUBE-SIZE的参数是0.579

![驱动器](./images/驱动器-18.png) 

立方体默认Z轴缩放是1，所以加上0.579就是1.579

![驱动器](./images/驱动器-19.png) 