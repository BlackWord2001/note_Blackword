# c++目录

## 预编译指令
**#pragma once** 是写在头文件开头的编译指令，使得编译器能够自动帮我们实现“只编译一次该头文件”，从而避免了多次include该头文件导致的重复定义/声明问题。
> 在没有#pragma once 之前，我们常用的方法是为这个头文件制定一个独一无二的宏名（比如说叫__Car__），然后使用#ifndef

```c++
#ifndef __Car__
#define __Car__

//头文件中的定义、声明
//...

#endif //__Car__
```

## 一些规范

+ **.h头文件中只有声明，没有定义** <br>
C++中的内联函数，内联函数的声明和定义分别在不同的源文件中，出现了链接错误。

**.h和.hpp区别**    
.hpp，本质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该.hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，采用hpp将大幅度减少调用project中的cpp文件数与编译次数，也不用再发布lib与dll文件，因此非常适合用来编写公用的开源库。

    hpp的优点不少，但是编写中有以下几点要注意：
    1、是Header Plus Plus的简写。（.h和.hpp就如同.c和.cpp似的）
    2、与.h类似，.hpp是C++程序头文件格式。
    3、是VCL专用的头文件,已预编译。
    4、是一般模板类的头文件。
    5、一般来说，.h里面只有声明，没有实现，而.hpp里声明实现都有，后者可以减少.cpp的数量。
    6、.h里面可以有using namespace std，而.hpp里则无。
    7、不可包含全局对象和全局函数。



# c++特性和语法

## 隐式的类型转换
static_cast< 想要的类型> (原数据)
在C++中，我们经常用到 隐式的类型 转换，比如 char->int , int ->double, 类层次结构中基类 和 派生类之间指针或引用的转换。
编译器隐式执行的任何类型转换都可以由 static_cast显式完成。
需要注意的是， 我们要 确保 目标数据类型 是 我们想要的类型，因为static_cast 不做 运行时的类型检查(RTTI,Run-time type identification)。

输入:
~~~c++
double d = 1.2;
int i= static_cast<int> (d); // 相当于 C语言的强制类型转换 (int)d;
cout << i << endl;
~~~
结果输出为：1

### static_cast   
    static_cast可以在类相关的指针中完成转换，不仅是向上转换，还有向下转换。在运行时期间不执行任何检查，以确保正在转换的对象实际上是目标类型的完整对象。因此它依靠编译器确保转换是否安全，另一方面，它没有dynamic_cast运行时检查的开销。

### dynamic_cast  
    dynamic_cast只能用于指向类的指针和引用(或void*)。它的目的是确保类型转换的结果指向目标指针类型的有效完整对象。
    将dynamic_cast用于引用时，其用法稍有不同：没有与空指针对应的引用值，也就是说没有空引用，引用必须要初始化，因此无法使用特殊的引用值来指示失败，当请求不正确时，dynamic_cast将引发bad_cast异常。
    向上转换：将指向派生类的指针转为指向基类的指针，其方式与隐式转换相同。

### const_cast
    这种类型的类型转换操作指针所指向的对象的常量，可以是要设置的，也可以是要删除的。例如，为了将const指针传递给需要非const实参的函数

### reinterpret_cast    
    reinterpret_cast可以将指针类型任意转换，甚至是不相关的类之间，使用场景：没啥场景，类似C语言中的强制类型转换，什么都可以转，万不得已不要使用，一般前三种转换方式不能解决问题了使用这种强制类型转换方式。操作结果是从一个指针到另一个指针的值的简单二进制拷贝。由reinterpret_cast执行但不能由static_cast执行的转换是基于重新解释类型的二进制表示的低级操作，在大多数情况下，这将导致特定于系统的代码，因此不可移植。

## if / switch 变量声明
在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终没有办法在 if 和 switch 语句中声明一个临时的变量，但是在C++17 消除了这一限制使得我们可以在 if（或 switch）中完成这一操作：

~~~c++
if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) {
		*itr = 4;
	}
~~~

## 结构化绑定
结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。

C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：

~~~c++
#include <iostream>
#include <tuple>

std::tuple<int, double, std::string> f() {
    return std::make_tuple(1, 2.3, "456");
}

int main() {
    auto [x, y, z] = f();
    std::cout << x << ", " << y << ", " << z << std::endl;
}
~~~

## 运算符
### 条件运算符 `?` `:` 
条件运算符它提供了一种表达简单 if-else 语句的简写方法。该运算符由问号`？`和冒号`:`组成  
↓ 如下代码 (x < y) 为 `ture` y = 10 就会被执行，为 `false` 执行 z = 20

~~~c++
// 表达式 ? 表达式 : 表达式 ;
x < 0 ? y = 10 : z = 20;

// 相当于如下
if (x < 0)
    y = 10；
else
    z = 20;
~~~

